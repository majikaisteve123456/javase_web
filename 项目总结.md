## Spring Boot项目的创建##

登录网址 start.spring.io

spring boot 1.5 就不支持velocity

目录的resource文件夹下的static 放图片、css、js脚本



package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class IndexController {

	@RequestMapping(path= {"/","/index"},method={RequestMethod.GET，RequestMethod.POST})
	@ResponseBody
	public String index()
	{
		return "hello";
	}
	
	@RequestMapping(value= {"/profile/{groupid}/{userid}"})
	@ResponseBody
	public String profile(@PathVariable("groupid") String groupid,
			               @PathVariable("userid") int userid,
			               @RequestParam(value= "type" ,defaultValue="1") int type,
			               @RequestParam(value="key",defaultValue="new") String key)
	{
		return String.format("%s ,%d ,%d ,%s ",groupid,userid,type,key);
		
	}
}



Model 是前端渲染与后台之间存储数据的模型

velocity 模板注释的规范：##xxxx     

$!{value1}

加上感叹号，如果值不存在就不显示


		@RequestMapping(value= {"/vm"})
		public String news(Model model)
		{
			model.addAttribute("value1", "abc");


​			
			Map<String,String> map=new HashMap<String,String>();
			for(int i=0;i<4;i++)
			{
				map.put(String.valueOf(i), String.valueOf(i*i));
			}
		
			model.addAttribute("map", map);
			model.addAttribute("user",new User("Steve"));
			
			return "news";
		}

模板 news.vm

```
#foreach($color in $colors)
Color $!{foreach.index}/$!{foreach.count}:$!{color}
#end

#foreach($key in $map.keySet())
Number $!(foreach.index)/$!{foreach.count}:$!{key} $map.get($key)
#end

#foreach($kv in $map.entrySet())
Number $!{foreach.index}/$!{foreach.count}:$!{kv.key} $!{kv.value}
#end
```



采用MVC，增加model层，创建包，然后创建相关的类

然后在controller层中

model.addAttribute("user",new User("majikai"));



## EL表达式##

EL：expression language

EL表达式比JSP 的内嵌的java代码更为方便、简洁





## 返回静态页面##

spring boot对于Thymeleaf提供了很好的支持，但默认不开通Thymeleaf模板，需要手动进行配置



在pom.xml 

`<dependency>`

` <groupId>org.springframework.boot</groupId>` 

` <artifactId>spring-boot-starter-thymeleaf</artifactId>` 

 </dependency>`

在application.properties添加如下配置

`# 定位模板的目录`

` spring.mvc.view.prefix=classpath:/templates/` 

` # 给返回的页面添加后缀名 ` 

`spring.mvc.view.suffix=.html`



将静态页面放置在/templates下





## HTTP相关的类##

HTTP请求可以包装成标准类,HttpServletRequest 将Http请求的许多字段包装好

@RequestMapping(value={"/request"})

@ResponseBody

public String request(HttpServletRequest request,HttpServletResponse response,HttpSession session)

{

for(Cookie cookie:request.getCookies())

{

   sb.append("Cookie:");

   sb.append(cookie.getName());

  sb.append(":");

  sb.append(cookie.getValue());

sb.append("<br>");}

StringBuilder sb=new StringBuilder（）；

sb.append("getMethod:"+request.getMethod());

sb.append("getPathInfo:"+request.getPathInfo());

sb.append("getPathInfo:"+request.getQueryString));

sb.append("getRequestURI:"+request.getRequestURI());

ruturn sb.toString();

}

@RequestMapping(value={"/response"})

@ResponseBody

public String response（@CookieValue(value="nowcoderid",defaultValue="a") String nowcoderid, @RequestParam(value="key",defaultValue="key") String key,

​                       @RequestParam(value="value",defaultValue="value") String value,HttpServletResponse response

）

{

   response.addCookie(new Cookie(key,value));

  response.addHeader(key,value);

return "NowCoderId From Cookie"+nowcoderId;



}



## 重定向和Error##

重定向

301：永久转移   当第二次访问该页面的时候浏览器直接跳转，没有再访问服务器

302：永久转移



@RequestMapping("/redirect/{code}")

publlic RedictView redict(@PathValue("code" int code))

{

  RedirectView red=new RedirectView("/",true);

   if(code==301){

​         red.setSatusCode(HttpStatus.MOVED_PERMANENTLY);

​    }

   return red;

}

另外一种简单的方法

@RequestMapping("/redirect/{code}")

public String redirect(@PathVariable('"code"') int code,HttpSession session){

session.setAttribute("msg","Jump from redirecct");

return "redirect:/";//跳转到首页

}

需要加上状态码

如果需要重定向到其他页面在其他页面在return“xxx”

  @RequestMapping("/")
  @ResponseBody
  public String index(HttpSession session)
  {
	  

	  return "hello"+session.getAttribute("msg");
  }
    

session表示长期的交互

## 自定义error以及相应的处理##

@RequestMapping("/admin")

@ResponseBody

public String admin(@RequestParam(value="key",required=false) String key)

{

   if("admin".equals(key))

  {

​    return "hello admin";

}

throw new IllegalArgumentException("Key 错误")；

}



@ExceptionHandler()

@ResponseBody

public String error(Exception e)

{

return "ERROR"+e.getMessage();

}



当url输入的资源没有的时候，可以利用重定向和异常处理来进行统一处理



## IOC##

在service包中添加service层的类，使用注释@Service

在控制层中的类中增加service层类的成员

不能用new的方法,使用注释@Autowired

就可以在控制层中调用方法



## AOP 面向切面编程##

面向切面，所有业务都要处理的业务

建一个包aspect

包中的类加上注解@Aspect

例子关于日志：

在方法执行之前用logger记录下来

方法执行之后用logger记录下来

java注释记得加上

@Aspect

@Component

public class LogAspect

{

   private static final Logger logger=LoggerFactory.getLogger(LogAspect.class);

@Before("execution(* com.nowcoder.controller.IndexController.*(..))")

  public void beforeMethod(JoinPoint joinPoint)

{





}

@After()

 public void  afterMethod("execution(* com.nowcoder.controller.IndexController.*(..))")

 {



 }

}

在控制层的类中加入成员

可以在控制层的类的方法中加入 logger.info("xxxx");

还有许多的logger的方法 error，debug 



@Before("execution(* com.nowcoder.controller.IndexController.*(..))")

解释：第一个* 表示返回值

​            第二个*表示通配符表示所有的方法

执行方法之前需要进行执行该方法

可以是*Controller 表示对于任何控制层类的方法

JoinPoint 表示被封装好的交互地方，叫做切点中

joinPoint 可以得到使用控制层类的方法的参数  joinPoint.getArgs()



切面编程可以用于优化统计




